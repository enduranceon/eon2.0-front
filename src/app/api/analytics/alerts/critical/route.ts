import { NextRequest, NextResponse } from 'next/server';

// Interface para alertas críticos
interface CriticalAlert {
  id: string;
  type: 'payment' | 'system' | 'user' | 'security' | 'performance';
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  timestamp: string;
  module: string;
  affectedUsers?: number;
  estimatedLoss?: number;
  actionRequired: boolean;
  autoResolved: boolean;
  resolvedBy?: string;
  resolvedAt?: string;
  resolution?: string;
  metadata?: Record<string, any>;
}

// Dados mockados de alertas críticos
const criticalAlerts: CriticalAlert[] = [
  {
    id: 'alert-001',
    type: 'payment',
    title: 'Pagamentos Pendentes Críticos',
    description: 'Múltiplos pagamentos estão atrasados há mais de 48 horas',
    severity: 'critical',
    timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(), // 2 horas atrás
    module: 'finance',
    affectedUsers: 15,
    estimatedLoss: 3250.50,
    actionRequired: true,
    autoResolved: false,
    metadata: {
      overdueDays: 2,
      totalAmount: 3250.50,
      paymentMethod: 'credit_card',
      failureReason: 'insufficient_funds'
    }
  },
  {
    id: 'alert-002',
    type: 'system',
    title: 'Performance Degradada',
    description: 'Sistema apresentando lentidão acima do limite aceitável',
    severity: 'high',
    timestamp: new Date(Date.now() - 30 * 60 * 1000).toISOString(), // 30 min atrás
    module: 'infrastructure',
    affectedUsers: 120,
    actionRequired: true,
    autoResolved: false,
    metadata: {
      avgResponseTime: 2.5,
      threshold: 1.5,
      cpuUsage: 87,
      memoryUsage: 92
    }
  },
  {
    id: 'alert-003',
    type: 'user',
    title: 'Pico de Cancelamentos',
    description: 'Aumento anormal de cancelamentos de assinaturas',
    severity: 'high',
    timestamp: new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString(), // 4 horas atrás
    module: 'subscription',
    affectedUsers: 8,
    estimatedLoss: 1890.00,
    actionRequired: true,
    autoResolved: false,
    metadata: {
      cancellationRate: 12.5,
      normalRate: 3.2,
      primaryReason: 'price_increase',
      timeframe: '24h'
    }
  },
  {
    id: 'alert-004',
    type: 'security',
    title: 'Tentativas de Login Suspeitas',
    description: 'Múltiplas tentativas de login falharam de IPs diferentes',
    severity: 'medium',
    timestamp: new Date(Date.now() - 6 * 60 * 60 * 1000).toISOString(), // 6 horas atrás
    module: 'security',
    affectedUsers: 3,
    actionRequired: true,
    autoResolved: false,
    metadata: {
      attemptCount: 25,
      uniqueIPs: 8,
      targetedAccounts: ['admin@enduranceon.com.br', 'coach@enduranceon.com.br'],
      geographic: ['Brazil', 'Russia', 'China']
    }
  },
  {
    id: 'alert-005',
    type: 'performance',
    title: 'Backup Falhou',
    description: 'Backup automático noturno não foi concluído com sucesso',
    severity: 'medium',
    timestamp: new Date(Date.now() - 8 * 60 * 60 * 1000).toISOString(), // 8 horas atrás
    module: 'backup',
    actionRequired: true,
    autoResolved: false,
    metadata: {
      backupType: 'full',
      failureStage: 'compression',
      dataSize: '2.5GB',
      errorCode: 'DISK_FULL'
    }
  }
];

// Simulação de novos alertas em tempo real
function generateNewAlert(): CriticalAlert {
  const alertTypes = ['payment', 'system', 'user', 'security', 'performance'] as const;
  const severities = ['critical', 'high', 'medium'] as const;
  const modules = ['finance', 'infrastructure', 'subscription', 'security', 'backup'];
  
  const randomType = alertTypes[Math.floor(Math.random() * alertTypes.length)];
  const randomSeverity = severities[Math.floor(Math.random() * severities.length)];
  const randomModule = modules[Math.floor(Math.random() * modules.length)];
  
  return {
    id: `alert-${Date.now()}`,
    type: randomType,
    title: `Alerta Automático - ${randomType.toUpperCase()}`,
    description: `Novo alerta gerado automaticamente pelo sistema de monitoramento`,
    severity: randomSeverity,
    timestamp: new Date().toISOString(),
    module: randomModule,
    affectedUsers: Math.floor(Math.random() * 50) + 1,
    estimatedLoss: Math.floor(Math.random() * 5000) + 100,
    actionRequired: true,
    autoResolved: false,
    metadata: {
      autoGenerated: true,
      priority: randomSeverity === 'critical' ? 1 : randomSeverity === 'high' ? 2 : 3
    }
  };
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '10');
    const severity = searchParams.get('severity');
    const module = searchParams.get('module');
    const includeResolved = searchParams.get('includeResolved') === 'true';
    
    // Filtrar alertas baseado nos parâmetros
    let filteredAlerts = [...criticalAlerts];
    
    if (severity) {
      filteredAlerts = filteredAlerts.filter(alert => alert.severity === severity);
    }
    
    if (module) {
      filteredAlerts = filteredAlerts.filter(alert => alert.module === module);
    }
    
    if (!includeResolved) {
      filteredAlerts = filteredAlerts.filter(alert => !alert.autoResolved);
    }
    
    // Adicionar novos alertas ocasionalmente (simulação)
    if (Math.random() < 0.3) { // 30% de chance
      const newAlert = generateNewAlert();
      filteredAlerts.unshift(newAlert);
    }
    
    // Ordenar por severidade e timestamp
    filteredAlerts.sort((a, b) => {
      const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
      const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];
      if (severityDiff !== 0) return severityDiff;
      return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
    });
    
    // Limitar resultados
    const paginatedAlerts = filteredAlerts.slice(0, limit);
    
    // Estatísticas
    const stats = {
      total: filteredAlerts.length,
      critical: filteredAlerts.filter(a => a.severity === 'critical').length,
      high: filteredAlerts.filter(a => a.severity === 'high').length,
      medium: filteredAlerts.filter(a => a.severity === 'medium').length,
      low: filteredAlerts.filter(a => a.severity === 'low').length,
      actionRequired: filteredAlerts.filter(a => a.actionRequired).length,
      estimatedTotalLoss: filteredAlerts.reduce((sum, a) => sum + (a.estimatedLoss || 0), 0)
    };
    
    return NextResponse.json({
      success: true,
      data: {
        alerts: paginatedAlerts,
        stats,
        pagination: {
          total: filteredAlerts.length,
          limit,
          showing: paginatedAlerts.length
        }
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao buscar alertas críticos:', error);
    
    return NextResponse.json({
      success: false,
      error: 'Erro interno do servidor',
      message: 'Não foi possível carregar os alertas críticos',
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validar dados obrigatórios
    if (!body.type || !body.title || !body.description || !body.severity || !body.module) {
      return NextResponse.json({
        success: false,
        error: 'Dados obrigatórios ausentes',
        message: 'type, title, description, severity e module são obrigatórios'
      }, { status: 400 });
    }
    
    // Criar novo alerta
    const newAlert: CriticalAlert = {
      id: `alert-${Date.now()}`,
      type: body.type,
      title: body.title,
      description: body.description,
      severity: body.severity,
      timestamp: new Date().toISOString(),
      module: body.module,
      affectedUsers: body.affectedUsers || 0,
      estimatedLoss: body.estimatedLoss || 0,
      actionRequired: body.actionRequired !== false,
      autoResolved: false,
      metadata: body.metadata || {}
    };
    
    // Adicionar à lista (em produção, salvaria no banco)
    criticalAlerts.unshift(newAlert);
    
    return NextResponse.json({
      success: true,
      data: newAlert,
      message: 'Alerta crítico criado com sucesso',
      timestamp: new Date().toISOString()
    }, { status: 201 });
    
  } catch (error) {
    console.error('Erro ao criar alerta crítico:', error);
    
    return NextResponse.json({
      success: false,
      error: 'Erro interno do servidor',
      message: 'Não foi possível criar o alerta crítico',
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const body = await request.json();
    const { searchParams } = new URL(request.url);
    const alertId = searchParams.get('id');
    
    if (!alertId) {
      return NextResponse.json({
        success: false,
        error: 'ID do alerta é obrigatório',
        message: 'Forneça o ID do alerta via query parameter ?id=alert-001'
      }, { status: 400 });
    }
    
    // Encontrar alerta
    const alertIndex = criticalAlerts.findIndex(alert => alert.id === alertId);
    if (alertIndex === -1) {
      return NextResponse.json({
        success: false,
        error: 'Alerta não encontrado',
        message: `Alerta com ID ${alertId} não foi encontrado`
      }, { status: 404 });
    }
    
    // Atualizar alerta
    const updatedAlert = {
      ...criticalAlerts[alertIndex],
      ...body,
      // Se estiver resolvendo o alerta
      ...(body.autoResolved && {
        autoResolved: true,
        resolvedAt: new Date().toISOString(),
        resolvedBy: body.resolvedBy || 'Sistema',
        resolution: body.resolution || 'Resolvido manualmente'
      })
    };
    
    criticalAlerts[alertIndex] = updatedAlert;
    
    return NextResponse.json({
      success: true,
      data: updatedAlert,
      message: 'Alerta atualizado com sucesso',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao atualizar alerta crítico:', error);
    
    return NextResponse.json({
      success: false,
      error: 'Erro interno do servidor',
      message: 'Não foi possível atualizar o alerta crítico',
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const alertId = searchParams.get('id');
    
    if (!alertId) {
      return NextResponse.json({
        success: false,
        error: 'ID do alerta é obrigatório',
        message: 'Forneça o ID do alerta via query parameter ?id=alert-001'
      }, { status: 400 });
    }
    
    // Encontrar alerta
    const alertIndex = criticalAlerts.findIndex(alert => alert.id === alertId);
    if (alertIndex === -1) {
      return NextResponse.json({
        success: false,
        error: 'Alerta não encontrado',
        message: `Alerta com ID ${alertId} não foi encontrado`
      }, { status: 404 });
    }
    
    // Remover alerta
    const removedAlert = criticalAlerts.splice(alertIndex, 1)[0];
    
    return NextResponse.json({
      success: true,
      data: removedAlert,
      message: 'Alerta removido com sucesso',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erro ao remover alerta crítico:', error);
    
    return NextResponse.json({
      success: false,
      error: 'Erro interno do servidor',
      message: 'Não foi possível remover o alerta crítico',
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
} 